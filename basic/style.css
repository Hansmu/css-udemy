/*
There are different types of selectors.
    Element selectors have nothing preceding them. h1
    A class selector has a dot preceding it. .banana
    An ID selector has a pound sign preceding it. #banana
    A universal selector is * which is used to display everything.
    Attribute selectors can be used to select elements by attribute. You use brackets to select the attribute. [disabled]
    Element selectors can be chained with class etc. It selects an element with that specific property. Ex a.active
*/


#product-overview {
    /*The URL reference to a file can be to a local file or to one online.*/
    background: url("./freedom.jpg");
    width: 100%;
    height: 528px;
    padding: 10px;
    /*!**/
    /*The padding gets added around the margin of the h1 tag.*/
    /*This is because the content of the element is considered the content + any margins it might have.*/
    /*Because margins and padding should not overlap, hence padding is added after the margin of the child*/
    /*elements.*/
    /**!*/
    /*padding: 20px;*/
    /*border: 5px black solid;*/
    /*margin: 20px;*/

    /* Adding width 100% would do nothing for this element, as it's a div. Block elements take up 100% of their area anyway. */
    /*
    Setting height to 100% wouldn't do much either. This is because it takes up as much space as the parent container would allow it to take up.
    It would only expand by the size of the margins that the header tag has. This is because while the parent takes up a larger area, then
    the parent only takes up as much space as its children require it to take up. If the child tried to take up 100%, then it would create a
    kind of infinite loop, so it cancels out. If you'd manually set the size of the parent to N pixels, then the 100% size would
    have an effect. Then it would take up 100% of the height of the parent.
    Basically, height percentages are calculated based on the height of the parent element. If say a parent element is 500 pixels and a child
    says that it is 100% height, then it'll be 500 pixels in size. This would apply for all the children that have the 100% constraint.
    So two elements with 100% height would both be 500 pixels each, causing the total area taken of the children to be 1000 pixels, while
    the parent element is 500 pixels.
    As the height percentages are dependent on the parent, then in order to have an element take up 100% of the page, then
    you'd have to pass to the very top element, which is the html tag, then the 100% would start propagating down. This is a
    more legacy option, though. There are more modern units to do this.
    */

    /*
    All elements have a certain way of calculating the width and height of an element. The default behavior is called
    content-box, it can be overridden using the box-sizing property. Border-box can be used to make it include the
    padding and border. There is no way to make it include the margin.
    box-sizing: border-box; is often the more convenient way to size the elements, so you may often find it being used
    as the default.
    */
}

/* Space separated selector does not mean direct child but any depth child. */
/*
There are however more combinators
    * Adjacent sibling is denoted with a +. div + p {}. This style would be applied to elements that are on
    the same level. In the example it would be applied to paragraph tags that come right after a div.
    * General sibling is denoted with a ~. div ~ p {}. On the same level as well, but now the element
    doesn't have to come right after the first element. It would just require for the first element to be
    somewhere before the second element on the same level.
    * Child is denoted with a >. div > p {}. Means that the element must be a direct child. So a paragraph
    tag inside the div tag. If there's a separate element wrapping the paragraph tag, then the style wouldn't
    get applied.
    * Descendant uses a whitespace. div p {}. The level doesn't matter here. Just that the paragraph tag should
    be somewhere inside of a div tag. Doesn't matter how deep the nesting of the child is.
 */
#product-overview h1 {
    color: white;
    /* Browsers have default fonts matching with certain values. For example with Chrome you have Helvetica
    matching with sans-serif. sans-serif, serif and monospace are always great values as they use the
    browser defaults. However, if you want to use a specific font, then you have to take a different approach.
    For example Google Fonts could be used to include fonts that don't exist by default. */
    font-family: 'Anton', sans-serif;
    /*
    We could overwrite this styling by setting font-family: inherit; to a h1 tag to make sure that specific
    tag would use inheritance over the specific rule. A better way might be to use an id or a combinator.
    A combinator allows to combine multiple selectors.
    */
}

.section-title {
    color: #2ddf5c;
}

/*
Cascading means that multiple rules can apply to the same element. One rule is a selector with the properties it sets.
So each CSS declaration in this file.
Specifity has to be used in order to resolve conflicts arising from applying multiple rules to the same element.
The order of specifity is as follows, with the last having the lowest specifity.
    Inline styles
    #ID selector
    .class, :pseudo-class and [attribute] selectors
    <Tag> and ::pseudo-element selectors
    Universal selector *

The universal selector, however, is very inefficient, so it's generally better to style the body tag.
*/

/*
Elements inherit styles from their parents both direct or indirect. Inheritance has a very low specifity.
Directly selecting an element has a higher specifity than inheritance.
*/
body {
    font-family: 'Montserrat', sans-serif;
    /* The browser adds margins to the body element by default. */
    margin: 0;
}

* {
    /*
    Cannot add this to the body element, as the inheritance doesn't work there. The reason is that the browser adds
    its own model for block level elements. So each element has to be manually overridden to make sure that border-box
    works.
    */
    box-sizing: border-box;
}

.main-header {
    background: #2ddf5c;
    padding: 8px 16px;
}

.main-header > div {
    display: inline-block;
    vertical-align: middle;
}

.main-header__brand {
    color: #0e4f1f;
    text-decoration: none;
    font-weight: bold;
    font-size: 22px;
}

.main-nav {
    display: inline-block;
    text-align: right;
    /*
    Not the best approach to read the pixels from a rendered page like that, but it'll work for now.
    Taking the exact size of the element won't work either, as a new line in our editor will add a new inline element with
    the content being a space. So we need to subtract a little bit extra. A hacky solution and a better solution will follow.
    */
    width: calc(100% - 67px);
    vertical-align: middle;
}

.main-nav__items {
    margin: 0;
    padding: 0;
    list-style: none; /* Reset the default behavior and remove bullet points. Padding 0 already does that, though. */
}

/*
Block level elements take up an entire line. An inline element does not, so several inline elements can be on the same line.
Both use the box model, but for an inline element we cannot set the margin top and bottom, as they aren't positioned in the
flow as block level elements are. The default behavior for elements can be changed using the display property.
inline-block mixes the functions. The elements can still go next to each other, but they behave like block level elements
when setting top and bottom margins, paddings etc, which are not possible for inline elements.

Inline boxes are laid out horizontally in a box called a line box. If there isn't enough horizontal space to fit all elements
into a single line, another line box is created under the first on. A single inline element may then be split across lines.
When an inline box is split between lines, then it is still logically a single box. So its horizontal paddings are applied
to the start and end of the box, not on every line it occupies. Vertical padding and borders are still applied. However,
it will not push away elements above or below it.
*/
.main-nav__item {
    display: inline-block;
    margin: 0 16px;
}

/* A separate class would have a higher performance, but in most cases you wouldn't even notice the difference. */
.main-nav__item a {
    color: #0e4f1f;
    /* Wouldn't work when setting on the parent, as everything that targets an element directly has a higher priority then
     inheritance.*/
    text-decoration: none;
    font-weight: bold;
    padding: 3px 0;
}

/*
Pseudo classes let us define styles for an element's specific state. Like hover and active. Defined with a single :, so :hover
Pseudo elements let us define styles for a specific part of an element. Defined with a double :, so ::after
*/
.main-nav__item a:hover,
/* A comma can be used to group combinators. A comma is not a combinator. */
.main-nav__item a:active{
    color: white;
    border-bottom: 2px solid white;
}

/*!* We can add extra content to an element using the after selector *!*/
/*.main-nav__item a::after {*/
/*    content: " (Link)";*/
/*    color: red;*/
/*}*/

/*
A :not() pseudoselector can be used to select all elements that are not with something.
The example selects any anchor tag that does not have the active class. Generally there's a
positive way of writing the same rules. It's easier to mess up with the not selector and you might
start adding needless complexity. :not() also takes more computation.
a:not(.active) {
    color: blue;
}
*/

/*
As we want to override the styles applied by another rule, then the order in which they are defined in
the CSS file does matter, because they have the same specifity.
*/
.main-nav__item--cta a {
    color: white;
    background: #ff1b68;
    padding: 8px 16px;
    border-radius: 8px;
}

/*
As we don't want any of the original styling, then we have to overwrite all of the properties, otherwise
it'll still use the existing properties from the other class.
*/
.main-nav__item--cta a:hover,
.main-nav__item--cta a:active {
    background: white;
    color: #ff1b68;
    border-bottom: none;
}