main {
    padding-top: 32px;
}

/*
For absolute and fixed position values, the element is taken out of the document flow. With relative, however,
it still remains in the document flow, except you can still apply top, right etc. to it. With relative the
movement properties move them from the element's initial position. It can happen that you exit the parent
element when using this. If you'd add overflow: hidden; then the element could be hidden away once it goes
out of bounds from the parent.
If you'd add the overflow hidden to the body element, then that wouldn't work. This is because the property
would be sent to the html tag and it has no effect there. However, you have overflow: hidden on both the
html and body element, then it works. Could also just have auto on the html element.
position:sticky is a hybrid of relative and fixed. When defining a top property, then it would define how
large does the space have to be between the top of the viewport and the border of the element before it
turns into a fixed element. When scrolling, then it gets limited by the parent. It doesn't extend over
the parent component.
*/
.package {
    border: 2px solid #0e4f1f;
    border-left: none;
    width: 80%;
    margin: 10px 0;
    border-radius: 4px;
    box-shadow: 2px 2px 2px 2px rgba(0, 0, 0, 0.3);
    position: relative;
}

.package:hover,
.package:active,
#free:hover,
#free:active {
    border: 2px solid #ffcede;
}

.package a {
    text-decoration: none;
    color: inherit;
    padding: 32px;
    display: block;
}

.package__sub-title {
    color: #979797;
}

.package__description {
    border: 2px solid #0e4f1f;
    background: white;
    color: #0e4f1f;
    padding: 16px;
    font-size: 20px;
}

#plus {
    background: rgba(213, 255, 220, 0.95);
}

#free {
    background: rgba(234, 252, 237, 0.95);
}

#premium {
    background: rgba(14, 79, 31, 0.95);
}

#premium .package__title {
    color: white;
}

#premium .package__sub-title {
    color: #bbb;
}

/* text-align right cannot be used as there's no inline element. float can be used in this case, but
it can produce strange issues, so it's not that widely used anymore these days. Flex is more popular.
float means that you want to overwrite the default positioning of an element and then push it elsewhere.
It takes an element out of the document flow. By default it could be used to position an image inside
of text. With elements, however, it needs a bit of a hack, to make sure that the elements don't take up
its position. */
#free {
    float: right;
    border-right: none;
    border-left: 2px solid #0e4f1f;
    box-shadow: 2px 2px 2px 2px rgba(0, 0, 0, 0.3);
    text-align: right;
}

/* Clear floats on both sides (left and right, which are the values that can be assigned to float).
Everything that comes after this class will not respect previous floats.
 */
.clearfix {
    clear: both;
}

/* All of our elements have a default z-index. It's set to auto and generally auto defaults to 0.
If you want to change the z-index, then you have to apply the position property. The z-index can also
be negative. So since we want our background image to be underneath all of the other elements, then
we should apply a minus z-index.
When using a non-static position, then each element has their own stacking context within them.
That means that the elements within a non-static position element compete only with the
other children of that parent when using z-index. If the parent has a lower z-index than non-static position
element, but the child has a higher one than the other non-static position element, then
that child will still be underneath the other non-static position element, as its z-index
would only apply in the context of that parent.
*/
.background {
    /*Background is actually just a shorthand. More things can be defined for the background.*/
    background: url('../images/plans-background.jpg');
    background-repeat: no-repeat;
    /*The cover property decides which property to use - width or height, depending on which is larger.
    It then decides which to use to fill the area, either width 100% or height 100%. It even zooms in
    if the element is smaller than your container. cover is the best option to make sure that there is
    no whitespace.

    An alternative could be contain, which makes sure that the entire image is in the container. So nothing
    would get cropped based on which dimension is higher. You'll most likely get whitespace with this.*/
    background-size: cover;
    /* The background position property works different based on the unit that you use. If you use pixels,
    then it gets pushed from that edge by the number of pixels, causing whitespace.
    If you use percentages, then*/
    background-position: 10px;
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
}

/*
If none of the parents of the element have a position property set, then it defaults to positioning relative
to the <html> element. If we have a position defined, then the positioning context for the absolute element
would be the closest parent with the position defined.
*/
.package__badge {
    position: absolute;
    top: 0;
    right: 0;
    margin: 20px;
    font-size: 12px;
    color: white;
    background: #ff5454;
    padding: 8px;
}